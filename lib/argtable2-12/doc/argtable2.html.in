<!-- Creator     : groff version 1.18.1 -->
<!-- CreationDate: Sun Feb 14 12:48:18 2010 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>ARGTABLE2</title>
</head>
<body>

<h1 align=center>ARGTABLE2</h1>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#FUNCTION REFERENCE">FUNCTION REFERENCE</a><br>
<a href="#FILES">FILES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>
<a name="NAME"></a>
<h2>NAME</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>argtable2 &minus; an ANSI C library for parsing GNU style
command line options</p>
</td>
</table>
<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>#include &lt;argtable2.h&gt;

struct <b>arg_lit
</b>struct <b>arg_int
</b>struct <b>arg_dbl
</b>struct <b>arg_str
</b>struct <b>arg_rex
</b>struct <b>arg_file
</b>struct <b>arg_date
</b>struct <b>arg_rem
</b>struct <b>arg_end

</b>struct <b>arg_lit</b>* <b>arg_lit0</b>(const char *shortopts, const char *longopts, const char *glossary)
struct <b>arg_lit</b>* <b>arg_lit1</b>(const char *shortopts, const char *longopts, const char *glossary)
struct <b>arg_lit</b>* <b>arg_litn</b>(const char *shortopts, const char *longopts, int mincount, int maxcount, const char *glossary)

struct <b>arg_int</b>* <b>arg_int0</b>(const char* shortopts, const char* longopts, const char* datatype, const char* glossary)
struct <b>arg_int</b>* <b>arg_int1</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
struct <b>arg_int</b>* <b>arg_intn</b>(const char *shortopts, const char *longopts, const char* datatype, int mincount, int maxcount, const char *glossary)

struct <b>arg_dbl</b>* <b>arg_dbl0</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
struct <b>arg_dbl</b>* <b>arg_dbl1</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
struct <b>arg_dbl</b>* <b>arg_dbln</b>(const char *shortopts, const char *longopts, const char* datatype, int mincount, int maxcount, const char *glossary)

struct <b>arg_str</b>* <b>arg_str0</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
struct <b>arg_str</b>* <b>arg_str1</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
struct <b>arg_str</b>* <b>arg_strn</b>(const char *shortopts, const char *longopts, const char* datatype, int mincount, int maxcount, const char *glossary)

struct <b>arg_rex</b>* <b>arg_rex0</b>(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary)
struct <b>arg_rex</b>* <b>arg_rex1</b>(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary)
struct <b>arg_rex</b>* <b>arg_rexn</b>(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int mincount, int maxcount, int flags, const char* glossary)

struct <b>arg_file</b>* <b>arg_file0</b>(const char* shortopts, const char* longopts, const char* datatype, const char* glossary)
struct <b>arg_file</b>* <b>arg_file1</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
struct <b>arg_file</b>* <b>arg_filen</b>(const char *shortopts, const char *longopts, const char* datatype, int mincount, int maxcount, const char *glossary)

struct <b>arg_date</b>* <b>arg_date0</b>const char* shortopts, const char* longopts, const char* format, const char* datatype, const char *glossary)
struct <b>arg_date</b>* <b>arg_date1</b>const char* shortopts, const char* longopts, const char* format, const char* datatype, const char *glossary)
struct <b>arg_date</b>* <b>arg_daten</b>const char* shortopts, const char* longopts, const char* format, const char* datatype, int mincount, int maxcount, const char *glossary)

struct <b>arg_rem</b>* <b>arg_rem</b>(const char *datatype, const char *glossary)
struct <b>arg_end</b>* <b>arg_end</b>(int maxerrors)

int <b>arg_nullcheck</b>(void **argtable)
int <b>arg_parse</b>(int argc, char **argv, void **argtable)
void <b>arg_print_option</b>(FILE *fp, const char *shortopts, const char *longopts, const char *datatype, const char *suffix)
void <b>arg_print_syntax</b>(FILE *fp, void **argtable, const char *suffix)
void <b>arg_print_syntaxv</b>(FILE *fp, void **argtable, const char *suffix)
void <b>arg_print_glossary</b>(FILE *fp, void **argtable, const char *format)
void <b>arg_print_glossary_gnu</b>(FILE *fp, void **argtable)
void <b>arg_print_errors</b>(FILE *fp, struct arg_end *end, const char *progname)
void <b>arg_freetable</b>(void **argtable, size_t n)

</pre>
</td>
</table>
<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Argtable is an ANSI C library for parsing GNU style
command line arguments with a minimum of fuss. It enables
the programmer to define their program&rsquo;s argument
syntax directly in the source code as an array of structs.
The command line is then parsed according to that
specification and the resulting values stored directly into
user&minus;defined program variables where they are
accessible to the main program.</p>
<!-- INDENTATION -->
<p>This man page is only for reference. Introductory
documentation and example source code is typically installed
under <b>@prefix@/share/doc/argtable2/</b> and is also
available from the argtable homepage at
http://argtable.sourceforge.net.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructing an arg_&lt;xxx&gt; data
structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Each <b>arg_&lt;xxx&gt;</b> struct has it own unique set
of constructor functions (defined above) which are typically
of the form:</p>
<!-- INDENTATION -->
<pre>struct <b>arg_int* arg_int0</b>(&quot;f&quot;, &quot;foo&quot;, &quot;&lt;int&gt;&quot;, &quot;the foo factor&quot;)
struct <b>arg_int* arg_int1</b>(&quot;f&quot;, &quot;foo&quot;, &quot;&lt;int&gt;&quot;, &quot;the foo factor&quot;)
struct <b>arg_int* arg_intn</b>(&quot;f&quot;, &quot;foo&quot;, &quot;&lt;int&gt;&quot;, 2, 4, &quot;the foo factor&quot;)
</pre>
<!-- INDENTATION -->
<p>where arg_int0() and arg_int1() are merely abbreviated
forms of arg_intn(). They are provided for convenience when
defining command line options that have either
zero&minus;or&minus;one occurrences (mincount=0,maxcount=1)
or exactly one occurrence (mincount=1,maxcount=1)
respectively.</p>
<!-- INDENTATION -->
<p>The shortopts=&quot;f&quot; parameter defines the
option&rsquo;s short form tag (eg -f). Multiple alternative
tags may be defined by concatenating them (eg
shortopts=&quot;abc&quot; defines options &minus;a, &minus;b
and &minus;c as equivalent). Specify shortopts=NULL when no
short option is required.</p>
<!-- INDENTATION -->
<p>The longopts=&quot;foo&quot; parameter defines the
option&rsquo;s long form tag (eg &minus;&minus;foo).
Multiple alternative long form tags may be separated by
commas (eg longopts=&quot;size,limit&quot; defines
&minus;&minus;size and &minus;&minus;limit). Do not include
any whitespace in the longopts string. Specify longopts=NULL
when no long option is required.</p>
<!-- INDENTATION -->
<p>If both shortopts and longopts are NULL then the option
is an untagged argument.</p>
<!-- INDENTATION -->
<p>The datatype=&quot;&lt;int&gt;&quot; parameter is a
descriptive string that denotes the argument data type in
error messages, as in &minus;&minus;foo=&lt;int&gt;.
Specifying datatype=NULL indicates the default datatype
should be used. Specifying datatype=&quot;&quot; effectively
disables the datatype display.</p>
<!-- INDENTATION -->
<p>The mincount=2 and maxcount=3 parameters specify the
minimum and maximum number of occurrences of the option on
the command line. If the command line option does not appear
the required number of times then the parser reports a
syntax error.</p>
<!-- INDENTATION -->
<p>The glossary=&quot;the foo factor&quot; parameter is
another descriptive string. It appears only in the glossary
table that is generated automatically by the
<b>arg_print_glossary</b> function (described later).</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><tt>&minus;f, -&minus;foo=&lt;int&gt; the foo
factor</tt></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Specifying a NULL glossary string causes that option to
be omitted from the glossary table.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>LITERAL COMMAND LINE OPTIONS</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>&minus;x, &minus;y, &minus;z, &minus;&minus;help,
&minus;&minus;verbose</p>
<!-- INDENTATION -->
<pre>struct <b>arg_lit
</b>   {
   struct <b>arg_hdr</b> hdr;  /* internal argtable header */
   int count;           /* number of matching command line options */
   };
</pre>
<!-- INDENTATION -->
<p>Literal options take no argument values. Upon a
successful parse, <i>count</i> is guaranteed to be within
the <i>mincount</i> and <i>maxcount</i> limits specified at
construction.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>INTEGER COMMAND LINE OPTIONS</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>&minus;x2, &minus;z 32MB, &minus;&minus;size=734kb,
&minus;&minus;hex 0x7, &minus;&minus;binary 0b10011010,
&minus;&minus;octal 0o123</p>
<!-- INDENTATION -->
<p>Argtable accepts command line integers in decimal (eg
123), hexadecimal (eg 0xFF12), octal (eg 0o123) and binary
(eg 0b0101110) formats. It also accepts integers that are
suffixed by &quot;KB&quot; (x1024), &quot;MB&quot;
(x1048576) or &quot;GB&quot; (x1073741824). All characters
are case insensitive</p>
<!-- INDENTATION -->
<pre>struct <b>arg_int
</b>   {
   struct <b>arg_hdr</b> hdr;  /* internal argtable header */
   int count;           /* number of values returned in ival[] */
   int *ival;           /* array of parsed integer values */
   };
</pre>
<!-- INDENTATION -->
<p>Upon a successful parse, <i>count</i> is guaranteed to be
within the <i>mincount</i> and <i>maxcount</i> limits set
for the option at construction with the appropriate values
store in the <i>ival</i> array. The parser will not accept
any values beyond that limit.</p>
<!-- INDENTATION -->
<p>Hint: It is legal to set default values in the
<i>ival</i> array prior to calling the <b>arg_parse</b>
function. Argtable will not alter <i>ival</i> entries for
which no command line argument is received.</p>
<!-- INDENTATION -->
<p>Hint: <i>Untagged</i> numeric arguments are not
recommended because GNU getopt mistakes negative values (eg
-123) for tagged options (eg -1 -2 -3). <i>Tagged</i>
arguments (eg -x -123, --tag=-123) do not suffer this
problem.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>REAL/DOUBLE COMMAND LINE OPTIONS</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>&minus;x2.234, &minus;y 7e&minus;03,
&minus;z&minus;3.3E+6, &minus;&minus;pi=3.1415,
&minus;&minus;tolerance 1.0E-6</p>
<!-- INDENTATION -->
<pre>struct <b>arg_dbl
</b>   {
   struct <b>arg_hdr</b> hdr;  /* internal argtable header */
   int count;           /* number of values returned in dval[] */
   double *dval;        /* array of parsed double values */
   };
</pre>
<!-- INDENTATION -->
<p>Same as <b>arg_int</b> except the parsed values are
stored in <i>dval</i> as doubles.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>STRING COMMAND LINE OPTIONS</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>&minus;Dmacro, &minus;t mytitle, &minus;m &quot;my
message string&quot;, &minus;&minus;title=&quot;hello
world&quot;</p>
<!-- INDENTATION -->
<pre>struct <b>arg_str
</b>   {
   struct <b>arg_hdr</b> hdr;  /* internal argtable header */
   int count;           /* number of strings returned in sval[] */
   const char **sval;   /* array of pointers to parsed argument strings */
   };
</pre>
<!-- INDENTATION -->
<p>Same as <b>arg_int</b> except pointers to the parsed
strings are returned in <i>sval</i> rather than a separate
copy of the string. Indeed, these pointers actually
reference the original string buffers stored in argv[], so
their contents should not be altered. However, it is legal
to initialise the string pointers in the <i>sval</i> array
to reference user-supplied default strings prior to calling
arg_parse. Argtable will only alter the contents of
<i>sval</i> when matching command line arguments are
detected.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>REGULAR EXPRESSION COMMAND LINE OPTIONS</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>commit, update, &minus;&minus;command=commit,
&minus;&minus;command=update</p>
<!-- INDENTATION -->
<pre>struct <b>arg_rex
</b>   {
   struct <b>arg_hdr</b> hdr;  /* internal argtable header */
   int count;           /* number of strings returned in sval[] */
   const char **sval;   /* array of pointers to parsed argument strings */
   };
</pre>
<!-- INDENTATION -->
<p>Similar to <b>arg_str</b> except the string argument
values are only accepted if they match a predefined regular
expression. Regular expressions are useful for matching
command line keywords, particularly if case insensitive
strings or pattern matching is required. The regular
expression is defined by the <i>pattern</i> parameter passed
to the <i>arg_rex</i> constructor and evaluated using regex.
Its behaviour can be controlled via standard regex bit
flags. These are passed to argtable via the <i>flags</i>
parameter in the <i>arg_rex</i> constructor. However the
only two of the standard regex flags are relevant to
argtable, namely REG_EXTENDED (use extended regular
expressions rather than basic ones) and REG_ICASE (ignore
case). These flags may be logically ORed if desired. See
<b>regex(3)</b> for more details of regular expression
matching.</p>
<!-- INDENTATION -->
<p>Restrictions: Argtable does not support <b>arg_rex</b>
functionality under Microsoft Windows platforms because the
Microsoft compilers do include the necessary <b>regex</b>
support as standard.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>FILENAME COMMAND LINE OPTIONS</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>&minus;o myfile, &minus;Ihome/foo/bar,
&minus;&minus;input=~/doc/letter.txt, &minus;&minus;name
a.out</p>
<!-- INDENTATION -->
<pre>struct <b>arg_file
</b>   {
   struct <b>arg_hdr</b> hdr;      /* internal argtable header */
   int count;               /* number of filename strings returned */
   const char **filename;   /* pointer to full filename string */
   const char **basename;   /* pointer to filename excluding leading path */
   const char **extension;  /* pointer to the filename extension */
   };
</pre>
<!-- INDENTATION -->
<p>Similar to <b>arg_str</b> but the argument strings are
presumed to refer to filenames hence some additional parsing
is done to separate out the filename&rsquo;s basename and
extension (if they exist). The three arrays filename[],
basename[], extension[] each store up to maxcount entries,
and the i&rsquo;th entry of each of these arrays refer to
different components of the same string buffer.</p>
<!-- INDENTATION -->
<p>For example, <b>&minus;o /home/heitmann/mydir/foo.txt</b>
would be parsed as:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%"></td>
<td width="83%">
<pre>filename[i]  = &quot;/home/heitmann/mydir/foo.txt&quot;
basename[i]  =                      &quot;foo.txt&quot;
extension[i] =                         &quot;.txt&quot;
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>If the filename has no leading path then the basename is
the same as the filename. If no extension could be
identified then it is given as NULL. Extensions are
considered as all text from the last dot in the
filename.</p>
<!-- INDENTATION -->
<p>Hint: Argtable only ever treats the filenames as strings
and never attempts to open them as files or perform any
directory lookups on them.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>DATE/TIME COMMAND LINE OPTIONS</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>12/31/04, &minus;d 1982&minus;11&minus;28,
&minus;&minus;time 23:59</p>
<!-- INDENTATION -->
<pre>struct <b>arg_date
</b>   {
   struct <b>arg_hdr</b> hdr;  /* internal argtable header */
   const char *format;  /* user-supplied date format string that was passed to constructor */
   int count;           /* number of datestamps returned in tmval[] */
   struct tm *tmval;    /* array of datestamps */
   };
</pre>
<!-- INDENTATION -->
<p>Accepts a timestamp string from the command line and
converts it to <i>struct tm</i> format using the system
<b>strptime</b> function. The time format is defined by the
<i>format</i> string passed to the <i>arg_date</i>
constructor, and is passed directly to <b>strptime</b>. See
<b>strptime(3)</b> for more details on the format
string.</p>
<!-- INDENTATION -->
<p>Restrictions: Argtable does not support <b>arg_date</b>
functionality under Microsoft Windows because the Microsoft
compilers do include the necessary <b>strptime</b> support
as standard.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>REMARK OPTIONS</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_rem
</b>   {
   struct <b>arg_hdr</b> hdr;  /* internal argtable header */
   };
</pre>
<!-- INDENTATION -->
<p>The <b>arg_rem</b> struct is a dummy struct in the sense
it does not represent a command line option to be parsed.
Instead it provides a means to include additional
<i>datatype</i> and <i>glossary</i> strings in the output of
the <b>arg_print_syntax</b>, <b>arg_print_syntaxv</b>, and
<b>arg_print_glossary functions</b>. As such, <b>arg_rem</b>
structs may be used in the argument table to insert
additional lines of text into the glossary descriptions or
to insert additional text fields into the syntax
description.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>END&minus;OF&minus;TABLE OPTION</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_end
</b>   {
   struct <b>arg_hdr</b> hdr;  /* internal argtable header */
   int count;           /* number of errors returned */
   int *error;          /* array of error codes */
   void **parent;       /* pointers to the erroneous command line options */
   const char **argval; /* pointers to the erroneous command line argument values */
   };

Every argument table must have an <b>arg_end</b> structure as its last entry.
It marks the end of an argument table and stores the error codes generated
by the parser as it processed the argument table.
The <i>maxerrors</i> parameter passed to the <b>arg_end</b> constructor
specifies the maximum number of errors that the structure can store.
Any further errors are discarded and replaced with the single error code
ARG_ELIMIT which is later reported to the user by the message &quot;too many errors&quot;.
A <i>maxerrors</i> limit of 20 is quite reasonable.

The <b>arg_print_errors</b> function will print the errors stored
in the <b>arg_end</b> struct in the same order as they occurred,
so there is no need to understand the internals of the <b>arg_end</b> struct.

</pre>
</td>
</table>
<a name="FUNCTION REFERENCE"></a>
<h2>FUNCTION REFERENCE</h2>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>int arg_nullcheck (void **argtable)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Returns non&minus;zero if the <i>argtable[]</i> array
contains any NULL entries up until the terminating
<b>arg_end*</b> entry. Returns zero otherwise.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>int arg_parse (int argc, char **argv, void
**argtable)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Parse the command line arguments in <i>argv[]</i> using
the command line syntax specified in <i>argtable[]</i>,
returning the number of errors encountered. Error details
are recorded in the argument table&rsquo;s <b>arg_end</b>
structure from where they can be displayed later with the
<b>arg_print_errors</b> function. Upon a successful parse,
the <b>arg_xxx</b> structures referenced in
<i>argtable[]</i> will contain the argument values extracted
from the command line.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_option (FILE *fp, const char
*shortopts, const char *longopts, const char *datatype,
const char *suffix)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This function prints an option&rsquo;s syntax, as in
<b>&minus;K|&minus;&minus;scalar=&lt;int&gt;</b>, where the
short options, long options, and datatype are all given as
parameters of this function. It is primarily used within the
<b>arg_xxx</b> structures&rsquo; <i>errorfn</i> functions as
a way of displaying an option&rsquo;s syntax inside of error
messages. However, it can also be used in user code if
desired. The <i>suffix</i> string is provided as a
convenience for appending newlines and so forth to the end
of the display and can be given as NULL if not required.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_syntax (FILE *fp, void **argtable,
const char *suffix)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Prints the GNU style command line syntax for the given
argument table, as in: [&minus;abcv]
[&minus;&minus;scalar=&lt;n&gt;] [&minus;o myfile]
&lt;file&gt; [&lt;file&gt;]<br>
The <i>suffix</i> string is provided as a convenience for
appending newlines and so forth to the end of the display
and can be given as NULL if not required.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_syntaxv (FILE *fp, void **argtable,
const char *suffix)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Prints the verbose form of the command line syntax for
the given argument table, as in: [&minus;a] [&minus;b]
[&minus;c] [&minus;&minus;scalar=&lt;n&gt;] [&minus;o
myfile] [&minus;v|&minus;&minus;verbose] &lt;file&gt;
[&lt;file&gt;]<br>
The <i>suffix</i> string is provided as a convenience for
appending newlines and so forth to the end of the display
and can be given as NULL if not required.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_glossary (FILE *fp, void **argtable,
const char *format)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Prints a glossary table describing each option in the
given argument table. The <i>format</i> string is passed to
printf to control the formatting of each entry in the the
glossary. It must have exactly two &quot;%s&quot; format
parameters as in &quot;%&minus;25s %s\n&quot;, the first is
for the option&rsquo;s syntax and the second for its
glossary string. If an option&rsquo;s glossary string is
NULL then that option in omitted from the glossary
display.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_glossary_gnu (FILE *fp, void
**argtable)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>An alternate form of <b>arg_print_glossary()</b> that
prints the glossary using strict GNU formatting conventions
wherein long options are vertically aligned in a second
column, and lines are wrapped at 80 characters.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_errors (FILE *fp, struct arg_end *end,
const char *progname)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Prints the details of all errors stored in the <i>end</i>
data structure. The <i>progname</i> string is prepended to
each error message.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_freetable (void ** argtable, size_t
n)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Deallocates the memory used by each <b>arg_xxx</b> struct
referenced by <i>argtable[]</i>. It does this by calling
<b>free</b> for each of the <i>n</i> pointers in the
argtable array and then nulling them for safety.</p>
</td>
</table>
<a name="FILES"></a>
<h2>FILES</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>@prefix@/include/argtable2.h<br>
@prefix@/lib/libargtable2.a<br>
@prefix@/lib/libargtable2.so<br>
@prefix@/man3/argtable2.3<br>
@prefix@/share/doc/argtable2/<br>
@prefix@/share/doc/argtable2/example/</p>
</td>
</table>
<a name="AUTHOR"></a>
<h2>AUTHOR</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Stewart Heitmann
&lt;sheitmann@users.sourceforge.net&gt;</p>
</td>
</table>
<hr>
</body>
</html>
